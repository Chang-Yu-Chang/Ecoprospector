---
title: "Community function for selection"
author: "Chang-Yu Chang"
date: "`r Sys.Date()`"
output:
  html_notebook:
    number_sections: no
    toc: yes
linkcolor: red
fontsize: 12pt
urlcolor: blue
---

```{r setup, include = FALSE}
# Knitr options
knitr::opts_chunk$set(
  cache = FALSE, 
  echo = FALSE,
	fig.align = "center",
	fig.height = 3,
	fig.width = 3)

# Packages
library(tidyverse)
library(data.table)
library(invnet)
library(reticulate) # Python interface
reticulate::use_python('~/anaconda3/bin/python3.7m') # Use this python version

# Local directory and functions
root <- rprojroot::is_r_package # Package root
write_all_csv <- TRUE
write_all_pdf <- TRUE
```

```{python echo = T}
import sys
print(sys.version)
```

# Settings

## Import packages

```{python echo = T}
from IPython.display import Image
from community_simulator import *
from community_simulator.usertools import *
from community_simulator.visualization import *
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.backends import backend_pdf as bpdf
#colors = sns.color_palette()
#%matplotlib inline

# Community selection module
from community_selection import *
from community_selection.A_experiment_functions import *
from community_selection.B_community_phenotypes import *
from community_selection.C_selection_algorithms import *
from community_selection.D_migration_algorithms import *
```


# Community functions

```{r}
source_python("script/01-community_selection-01-community_phenotypes.py")
```


**Consumers**

- Additive trait $\sum{\lambda_i n_i}$

- Complex trait $\sum{\lambda_i n_i} + \sum{\lambda_{ij} n_i n_j}$

- Additive trait with saturation $\sum{\frac{\lambda_i n_i}{n_i+k_i}}$

- Complex trait with saturation $\sum{\frac{\lambda_i n_i}{n_i+k_i}} + \sum{\frac{\lambda_{ij} n_i n_j}{n_i n _j+k_{ij}}}$


**Resources**

- Additive trait $\sum{\lambda_i R_i}$

- Complex trait $\sum{\lambda_i R_i} + \sum{\lambda_{ij} R_i R_j}$

- Additive trait with saturation $\sum{\frac{\lambda_i R_i}{R_i+k_i}}$

- Complex trait with saturation $\sum{\frac{\lambda_i R_i}{R_i+k_i}} + \sum{\frac{\lambda_{ij} R_i R_j}{R_i R_j+k_{ij}}}$


```{python}
def dNdt(N,R,params):
    return MakeConsumerDynamics(assumptions)(N,R,params)
def dRdt(N,R,params):
    return MakeResourceDynamics(assumptions)(N,R,params)
dynamics = [dNdt,dRdt]

# Make initial state
assumptions = a_default.copy()
params = MakeParams(assumptions)
init_state = MakeInitialState(assumptions)

# Make plate
plate = Community(init_state, dynamics, params, scale = 10**6, parallel = True) 
```


# Algorithms

```{python}
make_algorithm_library()
```


```{python}
params_algorithm = {"community_phenotype": "community_function_additive", "selection_algorithm": "no_selection", "migration_algorithm": "no_migration"}
```


```{python}
## Main function for simulating community
def simulate_community(plate, params_simulation, params_algorithm, file_name = "data/self_assembly-community", write_composition = False):
    """
    Simulate community dynamics by given experimental regimes
    
    plate = plate
    params_simulation = dictionary of parameters for running experiment
    params_algorithm = dictionary of algorithms that determine the selection regime, migration regime, and community pheotypes
    
    Return:
    community_composition = concatenated, melted panda dataframe of community and resource composition in each transfer
    community_function = melted panda dataframe of community function
    """
    # Empty list for saving data
    plate_data_list = list()
    community_function_list = list()

    # Save the inocula composition
    plate_data = reshape_plate_data(plate, transfer_loop_index = 0) # Initial state
    plate_data_list.append(plate_data)
    
    # Output the file if write_composition set True
    if write_composition == True:
        plate_data.to_csv(file_name + "-T" + "{:02d}".format(0) + ".txt", index = False)

    # Run simulation
    for i in range(0, params_simulation["n_transfer"]):
        
        # Propagation
        plate.Propagate(params_simulation["n_propagation"])
    
        # Append the composition to a list
        plate_data = reshape_plate_data(plate, transfer_loop_index = i + 1)
        plate_data_list.append(plate_data)

        ## Output the file if write_composition set True
        if write_composition == True:
            plate_data.to_csv(file_name + "-T" + "{:02d}".format(i+1) + ".txt", index = False)
        
        # Community phenotype
        community_function = globals()[params_algorithm["community_phenotype"]](plate)
        community_function_list.append(reshape_function_data(community_function))

        # Passage and tranfer matrix
        if selection_algorithm in ["exponealing", "exponealing2"]: # Propagation time dependent function
            transfer_matrix = globals()[params_algorithm["selection_algorithm"]](community_function, k)
        else:
            transfer_matrix = globals()[params_algorithm["selection_algorithm"]](community_function)
        
        plate.Passage(t * params_simulation["dilution"])
        
        # Migration
        m = globals()[params_algorithm["migration_algorithm"]](community_function) 
        plate.N = migrate_from_pool(plate, species_pool, m)
 

        # Transfer/passage by usigg transfer matrix. For simple passage, the transfer matrix is an identity matrix
        transfer_matrix = np.eye(plate.N.shape[1]) * params_simulation["dilution"]
        plate.Passage(transfer_matrix)
        
        # Print the propagation progress
        print("propagation: " + str(i+1)) 
        
    
    # Concatenate datafrom from different transfers
    plate_data_con = pd.concat(plate_data_list)
#    community_function_con = pd.concat(community_function_list)
    
    return plate_data_con, community_function_con
```






```{python}
def reshape_function_data(community_function, transfer_loop_index):
    temp_vector = community_function.copy()
    number_well = len(community_function)
    temp_df = pd.DataFrame({"Transfer": np.repeat(str(transfer_loop_index), number_well), "Well": ["W" + str(i) for i in range(number_well)], "CommunityPhenotype": temp_vector})

    return temp_df 

reshape_function_data(community_function_additive(plate), transfer_loop_index= 1)
```

```{python}
["W" + str(i) for i in range(10)]
```





```{r include = F}

## Selection algorithms
"
Students will work on putting together what literature has proposed

The proposed algorithm using perturbated migration

1. Find the best

2. Let it propagate to equilibrium

3. Keep it

4. Perturbate it by migration


# Simulation regions

210 speices in the universe of simulation

96 wells/replicate community

10 metacommunities, within which there are 96 species pools (soil samples) that has different power-law distribution for 210 species

8 community functions

10 selection algorithms

Run 4 replicate for each of the combinations

In total the number of wells is 

(10*8*10*4*96)
"
```









