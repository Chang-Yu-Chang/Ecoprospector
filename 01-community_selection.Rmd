---
title: "Pairwise competition using mechanistic consumer-resource models"
author: "Chang-Yu Chang"
date: "`r Sys.Date()`"
output:
  html_notebook:
    number_sections: no
    toc: yes
linkcolor: red
fontsize: 12pt
urlcolor: blue
---

```{r setup, include = FALSE}
# Knitr options
knitr::opts_chunk$set(
  cache = FALSE, 
  echo = FALSE,
	fig.align = "center",
	fig.height = 3,
	fig.width = 3)

# Packages
library(tidyverse)
library(data.table)
library(invnet)
library(reticulate) # Python interface
reticulate::use_python('~/anaconda3/bin/python3.7m') # Use this python version

# Local directory and functions
root <- rprojroot::is_r_package # Package root
write_all_csv <- TRUE
write_all_pdf <- TRUE
```

```{python}
import sys
print(sys.version)
```

# Settings

## Import packages

```{python echo = T}
from IPython.display import Image
from community_simulator import *
from community_simulator.usertools import *
from community_simulator.visualization import *
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.backends import backend_pdf as bpdf
#colors = sns.color_palette()
#%matplotlib inline
```

## Load functions

Essential functions for community self-assembly

```{r}
# Source python script, like source() in R
```


# Community function and selection algorithm

## Community functions

**Consumers**

- Additive trait $\sum{\lambda_i n_i}$

- Complex trait $\sum{\lambda_i n_i} + \sum{\lambda_{ij} n_i n_j}$

- Additive trait with saturation $\sum{\frac{\lambda_i n_i}{n_i+k_i}}$

- Complex trait with saturation $\sum{\frac{\lambda_i n_i}{n_i+k_i}} + \sum{\frac{\lambda_{ij} n_i n_j}{n_i n _j+k_{ij}}}$


**Resources**

- Additive trait $\sum{\lambda_i R_i}$

- Complex trait $\sum{\lambda_i R_i} + \sum{\lambda_{ij} R_i R_j}$

- Additive trait with saturation $\sum{\frac{\lambda_i R_i}{R_i+k_i}}$

- Complex trait with saturation $\sum{\frac{\lambda_i R_i}{R_i+k_i}} + \sum{\frac{\lambda_{ij} R_i R_j}{R_i R_j+k_{ij}}}$


```{python}
def dNdt(N,R,params):
    return MakeConsumerDynamics(assumptions)(N,R,params)
def dRdt(N,R,params):
    return MakeResourceDynamics(assumptions)(N,R,params)
dynamics = [dNdt,dRdt]

# Make initial state
assumptions = a_default.copy()
params = MakeParams(assumptions)
init_state = MakeInitialState(assumptions)

# Make plate
plate = Community(init_state, dynamics, params, scale = 10**6, parallel = True) 
```


```{python}
n = 210
species_function = np.random.normal(0, 1, size = n)

def community_function_additive(plate, species_function):
    """
    Additive community function
    
    plate = plate object from package
    species_function = an 1-D array with the length of the size of species pool
    """
    assert len(species_function) == plate.N.shape[0], "Length of species_function does not match species number in plate."
    
    community_function = np.sum(plate.N.values * species_function[:,None],axis=0)
    
    return community_function

community_function_additive(plate, np.random.normal(0, 1, size = 210))
```


```{python}
np.random.seed(0)
n = 210
species_function = np.array(np.random.normal(0, 1, size = n * n)).reshape(n,n)

def community_function_complex(plate, species_function):
    """
    Complex community function
    
    plate = plate object from package
    species_function = a n by n 2-D array; n is the size of species pool
    """
    assert len(species_function) == plate.N.shape[0], "Length of species_function does not match species number in plate."
    
    # Additive term; diagonal of the species function matrix
    additive_term = np.sum(plate.N.values * np.diag(species_function)[:,None], axis=0)

    # Interaction term
    from itertools import combinations 
    
    ## Upper triangle in the species function matrix; Excluding the diagonal 
    function_upper_triangle = np.triu(species_function, k = 1)
    ## Flatten the 2D array into an 1D array without 0
    function_upper_triangle = function_upper_triangle.flatten()
    function_interaction = [value for value in function_upper_triangle if value != 0]
    
    # 
    interaction_term = np.zeros(plate.N.shape[1])
    for i in range(plate.N.shape[1]):
        combn = list(combinations(plate.N.iloc[:,i], 2))
        interaction_term[i] = pd.DataFrame({"function": function_interaction, "n1": [element[0] for element in combn], "n2": [element[1] for element in combn]})
    

    
    # for i in range(len(species_function)):
    #     for j in range(len(species_function)):
    #         if i > j: # Only use the upper triangle
    #             np.sum(plate.N.values * )
    
    
    return additive_term + interaction_term


#community_function_complex(plate, species_function)

# 
S_tot = plate.N.shape[0]

for w in range(plate.N.shape[1]):
    # Indicex of alive species
    alive_species = np.where(plate.N.iloc[:,w] != 0)

"complex community trait"
#     for p in range()
# interaction_term = np.zeros(plate.N.shape[1])
# for i in range(plate.N.shape[1]):
#     combn = list(combinations(plate.N.iloc[:,i], 2))
#     print ([element[0] for element in combn])
    #interaction_term[i] = pd.DataFrame({"function": function_interaction, "n1": [element[0] for element in combn], "n2": [element[1] for element in combn]})
```


```{python}
ll = [0, 3,5,8,0, 4,6]
[element for element in ll if element != 0]
```


## Selection algorithms

Students will work on putting together what literature has proposed

The proposed algorithm using perturbated migration

1. Find the best

2. Let it propagate to equilibrium

3. Keep it

4. Perturbate it by migration


# Simulation regions

210 speices in the universe of simulation

96 wells/replicate community

10 metacommunities, within which there are 96 species pools (soil samples) that has different power-law distribution for 210 species

8 community functions

10 selection algorithms

Run 4 replicate for each of the combinations

In total the number of wells is 

```{r}
(10*8*10*4*96)
```






