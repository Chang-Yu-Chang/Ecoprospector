#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mar 09 2020
@author: changyuchang
"""

import numpy as np
import scipy as sp
import pandas as pd
from community_simulator import *
from community_simulator.usertools import *
from community_selection.A_experiment_functions import *


def make_assumptions(input_file,row):
  '''  Generate the assumptions dictionary from input file and row of input file '''
	#Load row dat and default assumptions
	row_dat = pd.read_csv(input_file, keep_default_na=False).iloc[row]
	assumptions = a_default.copy()
	original_params = MakeParams(assumptions.copy())
	#Update assumptions based on row_dat
	for k in row_dat.keys():
		#if NA default to original value 
		if k in assumptions.keys() and row_dat[k] != 'NA' :
			assumptions.update({k :row_dat[k]})
		elif k in assumptions.keys() and row_dat[k] == 'NA' :
			continue
		#some params for who we wan't to resort to there default value are not stored in assumptions but are generated by MakeParams
		elif k not in assumptions.keys() and k in original_params.keys() and row_dat[k] != 'NA':
			assumptions.update({k :row_dat[k]})
		elif k not in assumptions.keys() and k  in original_params.keys() and row_dat[k] == 'NA':
			assumptions.update({k:original_params[k]})
		else:
			if row_dat[k] != 'NA':
				assumptions.update({k :row_dat[k]})
			else:
				assumptions.update({k :np.nan})
				#Many of the paramaters not in a_default should be 
				
	#These two assumptions are generated from combinations of other paramaters
	assumptions.update({'SA' :row_dat['sn']*np.ones(row_dat['sf'])  }) #Number of consumers in each Specialist family
	assumptions.update({'MA' :row_dat['rn']*np.ones(row_dat['rf'])  }) #Number of resources in each class
	
	#MakeParams does not work with numpy type for R0_food so convert to base python
	assumptions['R0_food'] = assumptions['R0_food'].item()
	
	#When running monoculture (every isolate in monoculture)
	if assumptions['monoculture'] :
		assumptions.update({"n_wells": np.sum(assumptions["SA"])  + assumptions["Sgen"]})
	return assumptions
	
def draw_species_function(assumptions):
    """
    Draw species-specific functions
    
    assumptions = dictionary of metaparameters from community-simulator
    
    Return:
    function_species, function_interaction
    """
    # Total number of species in the pool
    S_tot = int(np.sum(assumptions['SA']) + assumptions['Sgen']) 
    
    # Species-specific function, 1-D array
    function_species = np.random.normal(0, assumptions["sigma"], size = S_tot)
    
    # Interaction-specific function, 2-D n by n array
    function_interaction = np.random.normal(0, assumptions["sigma"] * assumptions["alpha"], size = S_tot * S_tot).reshape(S_tot, S_tot)
    function_interaction_p25 = np.random.binomial(1, 0.25, S_tot**2).reshape(S_tot, S_tot) * np.array(np.random.normal(0, assumptions["sigma"] * assumptions["alpha"], size = S_tot * S_tot)).reshape(S_tot, S_tot)

    return function_species, function_interaction, function_interaction_p25

def save_plate(assumptions, plate):
    """ 
    Save the initial plate in a pickle file. Like saving a frozen stock at -80C
    """
    if assumptions['save_plate']:
        import dill as pickle
        with open(assumptions['output_dir'] + assumptions['selected_function'] + "-" + str(assumptions['seed']) + ".p", "wb") as f:
            pickle.dump(plate, f)
    # If need to read the frozen plate, use the code below
    #frozen_plate = pickle.load(open(assumptions['output_dir'] + assumptions['exp_id'] + ".p", "rb"))

def make_medium(plate_R,assumptions):
    """
    Design medium for the plate
    if assumptions['rich_medium'] == True, make rich medium
    """
    if assumptions['rich_medium'] == True:
        np.random.seed(1)
    
		# Total number of resource in this universe
        R_tot = plate_R.shape[0] 
    
		# Make empty plate
        R0 = np.zeros((plate_R.shape)) # Make empty plate
    
		# Resource index
        resource_index = plate_R.index 
    
		# Well index
        well_names = plate_R.columns
    
        resource_pool = np.random.uniform(0, 1, size = R_tot) # Uniform distribution
        resource_pool = resource_pool/np.sum(resource_pool)
        resource_list = np.random.choice(R_tot, size = assumptions["R0_food"], replace = True, p = resource_pool) # Draw from the pool
        my_tab = pd.crosstab(index = resource_list, columns = "count")
        food_compostion = np.ravel(my_tab.values)
        for i in range(plate_R.shape[1]):
            R0[my_tab.index.values,i] = food_compostion
        R0 = pd.DataFrame(R0, index = resource_index, columns = well_names)
    else:
        R0 = plate_R
    return R0

    
def make_plate(assumptions,params):
    """
    prepares the plate
    """
    
    # Make dynamical equations
    def dNdt(N,R,params):
        return MakeConsumerDynamics(assumptions)(N,R,params)
    def dRdt(N,R,params):
        return MakeResourceDynamics(assumptions)(N,R,params)
    dynamics = [dNdt,dRdt]
    
    # Make initial state
    init_state = MakeInitialState(assumptions)
    
    plate = Community(init_state, dynamics, params, scale = assumptions["scale"], parallel = False) 
    
    # Add media to plate (overrides community simulator)
    plate.R = make_medium(plate.R, assumptions)
    plate.R0 = make_medium(plate.R0, assumptions)  
	   
	# Add cells to plate (overrides community simulator)
    plate.N = sample_from_pool(plate.N, assumptions)
    
    
    return plate
	
def add_community_function(plate, assumptions, params):
    """
    Add the function attribute to the community
    
    For f1 and f3, add species_function 
    For f2 and f4, add interaction_function
    For f5, add invasion_plate_t0 and invasion_plate_t1
    For f6, f7, and f8, add resident_plate_t0_N, resident_plate_t1_N, resident_plate_t0_R, and resident_plate_t1_R
    
    if isolates calculate function for every isolate in monoculture.
    """
    
    #Generate per capita species function
    np.random.seed(assumptions['seed']) 
    function_species, function_interaction, function_interaction_p25 = draw_species_function(assumptions)
    
    # Species function, f1 and f3
    setattr(plate, "species_function", function_species) # Species function for additive community function

    # Interactive functions, f2 , f2b and f4
    setattr(plate, "interaction_function",function_interaction) # Interactive function for interactive community function
    setattr(plate, "interaction_function_p25", function_interaction_p25)


    # Invasion function f5 or knock_in with a threshold requires us to grow isolates in monoculture to obtain their abundance.
    if (assumptions["selected_function"] == 'f5_invader_growth') | (assumptions['knock_in'] and np.isfinite(assumptions['knock_in_threshold'])):
        print("\nStabilizing monoculture plate")
        # Keep the initial plate R0 for function f7 
        setattr(plate, "R0_initial", plate.R0)
        
        assumptions_invasion = assumptions.copy()
        params_invasion = params.copy()
        
		#Update assumptions
        assumptions_invasion.update({"n_wells": np.sum(assumptions["SA"])  + assumptions["Sgen"]})
        assumptions_invasion.update({"monoculture":True})

        # Make plates
        plate_invasion = make_plate(assumptions_invasion,params_invasion)
        
        # Grow the invader plate  to equilibrium
        for i in range(assumptions_invasion["n_transfer"] - assumptions_invasion["n_transfer_selection"]):
            plate_invasion.Propagate(assumptions_invasion["n_propagation"])
            plate_invasion = passage_monoculture(plate_invasion, assumptions_invasion["dilution"])
        
        #  1 final growth cycle before storing data
        plate_invasion.Propagate(assumptions_invasion["n_propagation"])
		
        # find well with highest biomass
        dominant_index = np.where(np.sum(plate_invasion.N, axis = 0) == np.max(np.sum(plate_invasion.N, axis = 0)))[0][0] # Find the well with the highest biomass

        # Duplicate the chosen community  to the entire plate and save this in a data.frame to be add to as an attribute of the plate
        invader_N = pd.DataFrame()
        invader_R = pd.DataFrame()
        invader_R0 = pd.DataFrame()

        for i in range(assumptions["n_wells"]):
            invader_N["W" + str(i)] = plate_invasion.N["W" + str(dominant_index)]
            invader_R["W" + str(i)] = plate_invasion.R["W" + str(dominant_index)]
            invader_R0["W" + str(i)] = plate_invasion.R0["W" + str(dominant_index)]

        #Add the invasion plate to the attr of community
        setattr(plate, "invader_N", invader_N)
        setattr(plate, "invader_R", invader_R)
        setattr(plate, "invader_R0", invader_R0)
        setattr(plate, "isolate_abundance", np.sum(plate_invasion.N,axis=1))     
        print("\nFinished Stabilizing monoculture plate")
    return plate
   
def prepare_experiment(assumptions):
    """
    Prepare the experimental setup for this simulation
    
    assumptions = dictionary of metaparameters
    
    Return: params, params_simulation, params_algorithm,plate
    """
    print("\nGenerate species paramaters")
    np.random.seed(assumptions['seed']) 
    params = MakeParams(assumptions) 
  
    print("\nConstructing plate")
    np.random.seed(assumptions['seed']) 
    plate = make_plate(assumptions,params)
    
    print("\nAdd community function to plate")
    plate = add_community_function(plate, assumptions, params)
    
    print("\nPrepare Protocol")
	#Extract Protocol from protocol database
    algorithms = make_algorithms(assumptions)
    params_algorithm = algorithms[algorithms['algorithm_name'] == assumptions['protocol']]
    
    #Params_simulation by default  contains all assumptions not stored in params.
    params_simulation  =  dict((k, assumptions[k]) for k in assumptions.keys() if k not in params.keys())
    
    #Save plate (will onlys save if assumptions specify that)
    save_plate(assumptions, plate)
    return params, params_simulation , params_algorithm, plate

# Make library of algorithms
def make_algorithm_library():
    """
    Show the table of algorithms in this package
    """
    import re
    import pandas as pd
    
    # Find directory of community_selection modultes
    import community_selection
    module_dir = community_selection.__file__
    module_dir = re.sub("__init__.py", "", module_dir) 
    
    # 
    algorithm_types = ["community_phenotypes", "selection_algorithms", "migration_algorithms"]
    algorithms = list()
    
    for i in range(len(algorithm_types)):
    
        # Open files
        file_algorithm_phenotype = open(module_dir + ["B", "C", "D"][i] + "_" + algorithm_types[i] + ".py", "r")
        
        # Read lines
        line_list = list()
        line = file_algorithm_phenotype.readline()
        cnt = 1
        
        while line:
            line = file_algorithm_phenotype.readline()
            line_list.append(line.strip())
            cnt += 1
        
        # Regular expression
        algorithm_names = re.findall("def \w+", " ".join(line_list))
        list_algorithm = [re.sub("^def ", "", x) for x in algorithm_names]
        
        # Write the files
        algorithms.append(pd.DataFrame({"AlgorithmType": re.sub("s$", "", algorithm_types[i]), "AlgorithmName": list_algorithm}))
     
    return pd.concat(algorithms)


# Plot community function
def plot_community_function(function_df):
    function_df.plot.scatter(x = "Transfer", y = "CommunityPhenotype")

# Plot transfer matrix
def plot_transfer_matrix(transfer_matrix):
    import seaborn as sns
    fig,ax=plt.subplots()
    sns.heatmap(transfer_matrix,ax=ax)
    ax.set_xlabel('Old well',fontsize=14)
    ax.set_ylabel('New well',fontsize=14)
    ax.set_title(r'Transfer Matrix',fontsize=14)
    plt.show()
    
    return fig
    


def make_algorithms(params_simulation):
    # Algorithms
    ## Simple screening
    simple_screening = pd.DataFrame({
        "algorithm_name": "simple_screening",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": "no_selection",
        "migration_algorithm": "no_migration"
    })

    ## Select top 25%
    select_top25 = pd.DataFrame({
        "algorithm_name": "select_top25",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["select_top25percent"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })  

    ## Select top 10%
    select_top10 = pd.DataFrame({
        "algorithm_name": "select_top10",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["select_top10percent"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })

    ## Pool top 25%
    pool_top25 = pd.DataFrame({
        "algorithm_name": "pool_top25",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["pool_top25percent"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })  

    ## Pool top 10%
    pool_top10 = pd.DataFrame({
        "algorithm_name": "pool_top10",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["pool_top10percent"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })  

    # Select top 25% and bottleneck or pool top 25% and bottleneck
    select_top25_bottleneck_10 = pd.DataFrame({
        "algorithm_name": "select_top25_bottleneck_10",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["select_top_25_bottleneck_10"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })  
    select_top25_bottleneck_100 = pd.DataFrame({
        "algorithm_name": "select_top25_bottleneck_100",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["select_top_25_bottleneck_100"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })  
    select_top25_bottleneck_1000 = pd.DataFrame({
        "algorithm_name": "select_top25_bottleneck_1000",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["select_top_25_bottleneck_1000"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })  
    select_top25_bottleneck_10000 = pd.DataFrame({
        "algorithm_name": "select_top25_bottleneck_10000",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["select_top_25_bottleneck_10000"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    select_top25_bottleneck_100000 = pd.DataFrame({
        "algorithm_name": "select_top25_bottleneck_100000",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["select_top_25_bottleneck_100000"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })  
    select_top25_bottleneck_1000000 = pd.DataFrame({
        "algorithm_name": "select_top25_bottleneck_1000000",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["select_top_25_bottleneck_1000000"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })  
    pool_top25_bottleneck_10 = pd.DataFrame({
        "algorithm_name": "pool_top25_bottleneck_10",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["pool_top_25_bottleneck_10"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })  
    pool_top25_bottleneck_100 = pd.DataFrame({
        "algorithm_name": "pool_top25_bottleneck_100",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["pool_top_25_bottleneck_100"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })  
    pool_top25_bottleneck_1000 = pd.DataFrame({
        "algorithm_name": "pool_top25_bottleneck_1000",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["pool_top_25_bottleneck_1000"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })  
    pool_top25_bottleneck_10000 = pd.DataFrame({
        "algorithm_name": "pool_top25_bottleneck_10000",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["pool_top_25_bottleneck_10000"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })  
    pool_top25_bottleneck_100000 = pd.DataFrame({
        "algorithm_name": "pool_top25_bottleneck_100000",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["pool_top_25_bottleneck_100000"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })  
    pool_top25_bottleneck_1000000 = pd.DataFrame({
        "algorithm_name": "pool_top25_bottleneck_1000000",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["pool_top_25_bottleneck_1000000"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })  
    
    # Arora2019
    Arora2019 = pd.DataFrame({
        "algorithm_name": "Arora2019",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["select_top33percent" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Blouin2015
    Blouin2015 = pd.DataFrame({
        "algorithm_name": "Blouin2015",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["pool_top10percent" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Blouin2015 control
    Blouin2015_control = pd.DataFrame({
        "algorithm_name": "Blouin2015_control",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["pool_top10percent_control" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Chang2020a
    Chang2020a = pd.DataFrame({
        "algorithm_name": "Chang2020a",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["select_top16percent" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })

    # Chang2020a_control
    Chang2020a_control = pd.DataFrame({
        "algorithm_name": "Chang2020a_control",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["select_top16percent_control" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })    
    
    # Chang2020b
    Chang2020b = pd.DataFrame({
        "algorithm_name": "Chang2020b",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["select_top25percent" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })

    # Chang2020b_control
    Chang2020b_control = pd.DataFrame({
        "algorithm_name": "Chang2020b_control",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["select_top25percent_control" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Jochum2019
    Jochum2019 = pd.DataFrame({
        "algorithm_name": "Jochum2019",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["pool_top10percent" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Mueller2019
    Mueller2019 = pd.DataFrame({
        "algorithm_name": "Mueller2019",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["pool_top25percent" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Panke-Buisse2015
    Panke_Buisse2015 = pd.DataFrame({
        "algorithm_name": "Panke_Buisse2015",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["pool_top28percent" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Penn2004
    Penn2004 = pd.DataFrame({
        "algorithm_name": "Penn2004",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["Williams2007a" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Raynaud2019a
    Raynaud2019a = pd.DataFrame({
        "algorithm_name": "Raynaud2019a",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["select_top10percent" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Raynaud2019b
    Raynaud2019b = pd.DataFrame({
        "algorithm_name": "Raynaud2019b",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["pool_top10percent" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Swenson2000a
    Swenson2000a = pd.DataFrame({
        "algorithm_name": "Swenson2000a",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["pool_top20percent" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Swenson2000a control
    Swenson2000a_control = pd.DataFrame({
        "algorithm_name": "Swenson2000a_control",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["pool_top20percent_control" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })

    # Swenson2000b
    Swenson2000b = pd.DataFrame({
        "algorithm_name": "Swenson2000b",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["select_top25percent" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Swenson2000b_control
    Swenson2000b_control = pd.DataFrame({
        "algorithm_name": "Swenson2000b_control",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["select_top25percent_control" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Swenson2000c
    Swenson2000c = pd.DataFrame({
        "algorithm_name": "Swenson2000c",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["pool_top20percent" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Williams2007a
    Williams2007a = pd.DataFrame({
        "algorithm_name": "Williams2007a",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["Williams2007a" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Williams2007b
    Williams2007b = pd.DataFrame({
        "algorithm_name": "Williams2007b",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["Williams2007b" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
        
    # Wright2019
    Wright2019 = pd.DataFrame({
        "algorithm_name": "Wright2019",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["pool_top10percent" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Wright2019_control
    Wright2019_control = pd.DataFrame({
        "algorithm_name": "Wright2019_control",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["pool_top10percent_control" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Xie2019a
    Xie2019a = pd.DataFrame({
        "algorithm_name": "Xie2019a",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["select_top_dog" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Xie2019b
    Xie2019b = pd.DataFrame({
        "algorithm_name": "Xie2019b",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["select_top10percent" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    # Arora2019
    Arora2019 = pd.DataFrame({
        "algorithm_name": "Arora2019_V2",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["Arora2019" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })    
    Arora2019_control = pd.DataFrame({
        "algorithm_name": "Arora2019_V2_control",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["Arora2019_control" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })       
    # Raynaud2019a
    Raynaud2019a	= pd.DataFrame({
        "algorithm_name": "Raynaud2019a",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["Raynaud2019a" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    Raynaud2019a_control	= pd.DataFrame({
        "algorithm_name": "Raynaud2019a_control",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["Raynaud2019a_control" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    }) 
    # Raynaud2019b
    Raynaud2019b = pd.DataFrame({
        "algorithm_name": "Raynaud2019b",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["Raynaud2019b" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    Raynaud2019b_control = pd.DataFrame({
        "algorithm_name": "Raynaud2019b_control",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["Raynaud2019b_control" for i in range(params_simulation["n_transfer_selection"])] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    
    #directed_selection
    directed_selection = pd.DataFrame({
        "algorithm_name": "directed_selection",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": ["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["select_top"] + ["no_selection" for i in range(params_simulation["n_transfer"] - params_simulation["n_transfer_selection"])], 
        "migration_algorithm": "no_migration"
    })
    
    #long experiments
    directed_selection_long = pd.DataFrame({
        "algorithm_name": "directed_selection_long",
        "transfer": range(1, params_simulation["n_transfer"] + 1),
        "community_phenotype": params_simulation["selected_function"],
        "selection_algorithm": np.tile(["no_selection" for i in range(params_simulation["n_transfer_selection"]-1)] + ["select_top"],int(params_simulation["n_transfer"]/params_simulation["n_transfer_selection"])).tolist(), 
        "migration_algorithm": "no_migration"
    })  
    
    
    # Save the algorithms
    algorithms = pd.concat([
        # Controls
        simple_screening, 
        select_top25, select_top10, 
        pool_top25, pool_top10,
        select_top25_bottleneck_10, select_top25_bottleneck_100, select_top25_bottleneck_1000, 
        select_top25_bottleneck_10000, select_top25_bottleneck_100000, select_top25_bottleneck_1000000,
        pool_top25_bottleneck_10, pool_top25_bottleneck_100, pool_top25_bottleneck_1000, 
        pool_top25_bottleneck_10000, pool_top25_bottleneck_100000, pool_top25_bottleneck_1000000,
        # Literature
        Arora2019, Blouin2015, Blouin2015_control, Chang2020a, Chang2020a_control, Chang2020b, Chang2020b_control, 
        Jochum2019, Mueller2019, Panke_Buisse2015, Penn2004,
        Raynaud2019a, Raynaud2019b, Swenson2000a, Swenson2000a_control, Swenson2000b, Swenson2000b_control, Swenson2000c,
        Williams2007a, Williams2007b, Wright2019, Wright2019_control, Xie2019a, Xie2019b,
        Arora2019, Arora2019_control, Raynaud2019a, Raynaud2019a_control, Raynaud2019b, Raynaud2019b_control,
        # directed selection
        directed_selection,directed_selection_long])
    
    return algorithms
